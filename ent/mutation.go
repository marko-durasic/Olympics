// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/marko-durasic/olympics/ent/combinedsport"
	"github.com/marko-durasic/olympics/ent/individualsport"
	"github.com/marko-durasic/olympics/ent/predicate"
	"github.com/marko-durasic/olympics/ent/teamsport"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCombinedSport   = "CombinedSport"
	TypeIndividualSport = "IndividualSport"
	TypeTeamSport       = "TeamSport"
)

// CombinedSportMutation represents an operation that mutates the CombinedSport nodes in the graph.
type CombinedSportMutation struct {
	config
	op             Op
	typ            string
	id             *int
	country        *string
	sport          *string
	gold           *int
	addgold        *int
	silver         *int
	addsilver      *int
	bronze         *int
	addbronze      *int
	points         *int
	addpoints      *int
	total_score    *int
	addtotal_score *int
	population     *int
	addpopulation  *int
	per_capita     *float64
	addper_capita  *float64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CombinedSport, error)
	predicates     []predicate.CombinedSport
}

var _ ent.Mutation = (*CombinedSportMutation)(nil)

// combinedsportOption allows management of the mutation configuration using functional options.
type combinedsportOption func(*CombinedSportMutation)

// newCombinedSportMutation creates new mutation for the CombinedSport entity.
func newCombinedSportMutation(c config, op Op, opts ...combinedsportOption) *CombinedSportMutation {
	m := &CombinedSportMutation{
		config:        c,
		op:            op,
		typ:           TypeCombinedSport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCombinedSportID sets the ID field of the mutation.
func withCombinedSportID(id int) combinedsportOption {
	return func(m *CombinedSportMutation) {
		var (
			err   error
			once  sync.Once
			value *CombinedSport
		)
		m.oldValue = func(ctx context.Context) (*CombinedSport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CombinedSport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCombinedSport sets the old CombinedSport of the mutation.
func withCombinedSport(node *CombinedSport) combinedsportOption {
	return func(m *CombinedSportMutation) {
		m.oldValue = func(context.Context) (*CombinedSport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CombinedSportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CombinedSportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CombinedSportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CombinedSportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CombinedSport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountry sets the "country" field.
func (m *CombinedSportMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CombinedSportMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *CombinedSportMutation) ResetCountry() {
	m.country = nil
}

// SetSport sets the "sport" field.
func (m *CombinedSportMutation) SetSport(s string) {
	m.sport = &s
}

// Sport returns the value of the "sport" field in the mutation.
func (m *CombinedSportMutation) Sport() (r string, exists bool) {
	v := m.sport
	if v == nil {
		return
	}
	return *v, true
}

// OldSport returns the old "sport" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldSport(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSport: %w", err)
	}
	return oldValue.Sport, nil
}

// ResetSport resets all changes to the "sport" field.
func (m *CombinedSportMutation) ResetSport() {
	m.sport = nil
}

// SetGold sets the "gold" field.
func (m *CombinedSportMutation) SetGold(i int) {
	m.gold = &i
	m.addgold = nil
}

// Gold returns the value of the "gold" field in the mutation.
func (m *CombinedSportMutation) Gold() (r int, exists bool) {
	v := m.gold
	if v == nil {
		return
	}
	return *v, true
}

// OldGold returns the old "gold" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldGold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGold: %w", err)
	}
	return oldValue.Gold, nil
}

// AddGold adds i to the "gold" field.
func (m *CombinedSportMutation) AddGold(i int) {
	if m.addgold != nil {
		*m.addgold += i
	} else {
		m.addgold = &i
	}
}

// AddedGold returns the value that was added to the "gold" field in this mutation.
func (m *CombinedSportMutation) AddedGold() (r int, exists bool) {
	v := m.addgold
	if v == nil {
		return
	}
	return *v, true
}

// ResetGold resets all changes to the "gold" field.
func (m *CombinedSportMutation) ResetGold() {
	m.gold = nil
	m.addgold = nil
}

// SetSilver sets the "silver" field.
func (m *CombinedSportMutation) SetSilver(i int) {
	m.silver = &i
	m.addsilver = nil
}

// Silver returns the value of the "silver" field in the mutation.
func (m *CombinedSportMutation) Silver() (r int, exists bool) {
	v := m.silver
	if v == nil {
		return
	}
	return *v, true
}

// OldSilver returns the old "silver" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldSilver(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSilver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSilver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSilver: %w", err)
	}
	return oldValue.Silver, nil
}

// AddSilver adds i to the "silver" field.
func (m *CombinedSportMutation) AddSilver(i int) {
	if m.addsilver != nil {
		*m.addsilver += i
	} else {
		m.addsilver = &i
	}
}

// AddedSilver returns the value that was added to the "silver" field in this mutation.
func (m *CombinedSportMutation) AddedSilver() (r int, exists bool) {
	v := m.addsilver
	if v == nil {
		return
	}
	return *v, true
}

// ResetSilver resets all changes to the "silver" field.
func (m *CombinedSportMutation) ResetSilver() {
	m.silver = nil
	m.addsilver = nil
}

// SetBronze sets the "bronze" field.
func (m *CombinedSportMutation) SetBronze(i int) {
	m.bronze = &i
	m.addbronze = nil
}

// Bronze returns the value of the "bronze" field in the mutation.
func (m *CombinedSportMutation) Bronze() (r int, exists bool) {
	v := m.bronze
	if v == nil {
		return
	}
	return *v, true
}

// OldBronze returns the old "bronze" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldBronze(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBronze is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBronze requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBronze: %w", err)
	}
	return oldValue.Bronze, nil
}

// AddBronze adds i to the "bronze" field.
func (m *CombinedSportMutation) AddBronze(i int) {
	if m.addbronze != nil {
		*m.addbronze += i
	} else {
		m.addbronze = &i
	}
}

// AddedBronze returns the value that was added to the "bronze" field in this mutation.
func (m *CombinedSportMutation) AddedBronze() (r int, exists bool) {
	v := m.addbronze
	if v == nil {
		return
	}
	return *v, true
}

// ResetBronze resets all changes to the "bronze" field.
func (m *CombinedSportMutation) ResetBronze() {
	m.bronze = nil
	m.addbronze = nil
}

// SetPoints sets the "points" field.
func (m *CombinedSportMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *CombinedSportMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *CombinedSportMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *CombinedSportMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *CombinedSportMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetTotalScore sets the "total_score" field.
func (m *CombinedSportMutation) SetTotalScore(i int) {
	m.total_score = &i
	m.addtotal_score = nil
}

// TotalScore returns the value of the "total_score" field in the mutation.
func (m *CombinedSportMutation) TotalScore() (r int, exists bool) {
	v := m.total_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalScore returns the old "total_score" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldTotalScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalScore: %w", err)
	}
	return oldValue.TotalScore, nil
}

// AddTotalScore adds i to the "total_score" field.
func (m *CombinedSportMutation) AddTotalScore(i int) {
	if m.addtotal_score != nil {
		*m.addtotal_score += i
	} else {
		m.addtotal_score = &i
	}
}

// AddedTotalScore returns the value that was added to the "total_score" field in this mutation.
func (m *CombinedSportMutation) AddedTotalScore() (r int, exists bool) {
	v := m.addtotal_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalScore resets all changes to the "total_score" field.
func (m *CombinedSportMutation) ResetTotalScore() {
	m.total_score = nil
	m.addtotal_score = nil
}

// SetPopulation sets the "population" field.
func (m *CombinedSportMutation) SetPopulation(i int) {
	m.population = &i
	m.addpopulation = nil
}

// Population returns the value of the "population" field in the mutation.
func (m *CombinedSportMutation) Population() (r int, exists bool) {
	v := m.population
	if v == nil {
		return
	}
	return *v, true
}

// OldPopulation returns the old "population" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldPopulation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopulation: %w", err)
	}
	return oldValue.Population, nil
}

// AddPopulation adds i to the "population" field.
func (m *CombinedSportMutation) AddPopulation(i int) {
	if m.addpopulation != nil {
		*m.addpopulation += i
	} else {
		m.addpopulation = &i
	}
}

// AddedPopulation returns the value that was added to the "population" field in this mutation.
func (m *CombinedSportMutation) AddedPopulation() (r int, exists bool) {
	v := m.addpopulation
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulation resets all changes to the "population" field.
func (m *CombinedSportMutation) ResetPopulation() {
	m.population = nil
	m.addpopulation = nil
}

// SetPerCapita sets the "per_capita" field.
func (m *CombinedSportMutation) SetPerCapita(f float64) {
	m.per_capita = &f
	m.addper_capita = nil
}

// PerCapita returns the value of the "per_capita" field in the mutation.
func (m *CombinedSportMutation) PerCapita() (r float64, exists bool) {
	v := m.per_capita
	if v == nil {
		return
	}
	return *v, true
}

// OldPerCapita returns the old "per_capita" field's value of the CombinedSport entity.
// If the CombinedSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CombinedSportMutation) OldPerCapita(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerCapita is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerCapita requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerCapita: %w", err)
	}
	return oldValue.PerCapita, nil
}

// AddPerCapita adds f to the "per_capita" field.
func (m *CombinedSportMutation) AddPerCapita(f float64) {
	if m.addper_capita != nil {
		*m.addper_capita += f
	} else {
		m.addper_capita = &f
	}
}

// AddedPerCapita returns the value that was added to the "per_capita" field in this mutation.
func (m *CombinedSportMutation) AddedPerCapita() (r float64, exists bool) {
	v := m.addper_capita
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerCapita resets all changes to the "per_capita" field.
func (m *CombinedSportMutation) ResetPerCapita() {
	m.per_capita = nil
	m.addper_capita = nil
}

// Where appends a list predicates to the CombinedSportMutation builder.
func (m *CombinedSportMutation) Where(ps ...predicate.CombinedSport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CombinedSportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CombinedSportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CombinedSport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CombinedSportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CombinedSportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CombinedSport).
func (m *CombinedSportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CombinedSportMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.country != nil {
		fields = append(fields, combinedsport.FieldCountry)
	}
	if m.sport != nil {
		fields = append(fields, combinedsport.FieldSport)
	}
	if m.gold != nil {
		fields = append(fields, combinedsport.FieldGold)
	}
	if m.silver != nil {
		fields = append(fields, combinedsport.FieldSilver)
	}
	if m.bronze != nil {
		fields = append(fields, combinedsport.FieldBronze)
	}
	if m.points != nil {
		fields = append(fields, combinedsport.FieldPoints)
	}
	if m.total_score != nil {
		fields = append(fields, combinedsport.FieldTotalScore)
	}
	if m.population != nil {
		fields = append(fields, combinedsport.FieldPopulation)
	}
	if m.per_capita != nil {
		fields = append(fields, combinedsport.FieldPerCapita)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CombinedSportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case combinedsport.FieldCountry:
		return m.Country()
	case combinedsport.FieldSport:
		return m.Sport()
	case combinedsport.FieldGold:
		return m.Gold()
	case combinedsport.FieldSilver:
		return m.Silver()
	case combinedsport.FieldBronze:
		return m.Bronze()
	case combinedsport.FieldPoints:
		return m.Points()
	case combinedsport.FieldTotalScore:
		return m.TotalScore()
	case combinedsport.FieldPopulation:
		return m.Population()
	case combinedsport.FieldPerCapita:
		return m.PerCapita()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CombinedSportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case combinedsport.FieldCountry:
		return m.OldCountry(ctx)
	case combinedsport.FieldSport:
		return m.OldSport(ctx)
	case combinedsport.FieldGold:
		return m.OldGold(ctx)
	case combinedsport.FieldSilver:
		return m.OldSilver(ctx)
	case combinedsport.FieldBronze:
		return m.OldBronze(ctx)
	case combinedsport.FieldPoints:
		return m.OldPoints(ctx)
	case combinedsport.FieldTotalScore:
		return m.OldTotalScore(ctx)
	case combinedsport.FieldPopulation:
		return m.OldPopulation(ctx)
	case combinedsport.FieldPerCapita:
		return m.OldPerCapita(ctx)
	}
	return nil, fmt.Errorf("unknown CombinedSport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CombinedSportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case combinedsport.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case combinedsport.FieldSport:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSport(v)
		return nil
	case combinedsport.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGold(v)
		return nil
	case combinedsport.FieldSilver:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilver(v)
		return nil
	case combinedsport.FieldBronze:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBronze(v)
		return nil
	case combinedsport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case combinedsport.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalScore(v)
		return nil
	case combinedsport.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulation(v)
		return nil
	case combinedsport.FieldPerCapita:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerCapita(v)
		return nil
	}
	return fmt.Errorf("unknown CombinedSport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CombinedSportMutation) AddedFields() []string {
	var fields []string
	if m.addgold != nil {
		fields = append(fields, combinedsport.FieldGold)
	}
	if m.addsilver != nil {
		fields = append(fields, combinedsport.FieldSilver)
	}
	if m.addbronze != nil {
		fields = append(fields, combinedsport.FieldBronze)
	}
	if m.addpoints != nil {
		fields = append(fields, combinedsport.FieldPoints)
	}
	if m.addtotal_score != nil {
		fields = append(fields, combinedsport.FieldTotalScore)
	}
	if m.addpopulation != nil {
		fields = append(fields, combinedsport.FieldPopulation)
	}
	if m.addper_capita != nil {
		fields = append(fields, combinedsport.FieldPerCapita)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CombinedSportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case combinedsport.FieldGold:
		return m.AddedGold()
	case combinedsport.FieldSilver:
		return m.AddedSilver()
	case combinedsport.FieldBronze:
		return m.AddedBronze()
	case combinedsport.FieldPoints:
		return m.AddedPoints()
	case combinedsport.FieldTotalScore:
		return m.AddedTotalScore()
	case combinedsport.FieldPopulation:
		return m.AddedPopulation()
	case combinedsport.FieldPerCapita:
		return m.AddedPerCapita()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CombinedSportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case combinedsport.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGold(v)
		return nil
	case combinedsport.FieldSilver:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSilver(v)
		return nil
	case combinedsport.FieldBronze:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBronze(v)
		return nil
	case combinedsport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case combinedsport.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalScore(v)
		return nil
	case combinedsport.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulation(v)
		return nil
	case combinedsport.FieldPerCapita:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerCapita(v)
		return nil
	}
	return fmt.Errorf("unknown CombinedSport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CombinedSportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CombinedSportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CombinedSportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CombinedSport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CombinedSportMutation) ResetField(name string) error {
	switch name {
	case combinedsport.FieldCountry:
		m.ResetCountry()
		return nil
	case combinedsport.FieldSport:
		m.ResetSport()
		return nil
	case combinedsport.FieldGold:
		m.ResetGold()
		return nil
	case combinedsport.FieldSilver:
		m.ResetSilver()
		return nil
	case combinedsport.FieldBronze:
		m.ResetBronze()
		return nil
	case combinedsport.FieldPoints:
		m.ResetPoints()
		return nil
	case combinedsport.FieldTotalScore:
		m.ResetTotalScore()
		return nil
	case combinedsport.FieldPopulation:
		m.ResetPopulation()
		return nil
	case combinedsport.FieldPerCapita:
		m.ResetPerCapita()
		return nil
	}
	return fmt.Errorf("unknown CombinedSport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CombinedSportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CombinedSportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CombinedSportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CombinedSportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CombinedSportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CombinedSportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CombinedSportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CombinedSport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CombinedSportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CombinedSport edge %s", name)
}

// IndividualSportMutation represents an operation that mutates the IndividualSport nodes in the graph.
type IndividualSportMutation struct {
	config
	op             Op
	typ            string
	id             *int
	country        *string
	sport          *string
	gold           *int
	addgold        *int
	silver         *int
	addsilver      *int
	bronze         *int
	addbronze      *int
	points         *int
	addpoints      *int
	total_score    *int
	addtotal_score *int
	population     *int
	addpopulation  *int
	per_capita     *float64
	addper_capita  *float64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*IndividualSport, error)
	predicates     []predicate.IndividualSport
}

var _ ent.Mutation = (*IndividualSportMutation)(nil)

// individualsportOption allows management of the mutation configuration using functional options.
type individualsportOption func(*IndividualSportMutation)

// newIndividualSportMutation creates new mutation for the IndividualSport entity.
func newIndividualSportMutation(c config, op Op, opts ...individualsportOption) *IndividualSportMutation {
	m := &IndividualSportMutation{
		config:        c,
		op:            op,
		typ:           TypeIndividualSport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndividualSportID sets the ID field of the mutation.
func withIndividualSportID(id int) individualsportOption {
	return func(m *IndividualSportMutation) {
		var (
			err   error
			once  sync.Once
			value *IndividualSport
		)
		m.oldValue = func(ctx context.Context) (*IndividualSport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IndividualSport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndividualSport sets the old IndividualSport of the mutation.
func withIndividualSport(node *IndividualSport) individualsportOption {
	return func(m *IndividualSportMutation) {
		m.oldValue = func(context.Context) (*IndividualSport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndividualSportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndividualSportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndividualSportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndividualSportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IndividualSport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountry sets the "country" field.
func (m *IndividualSportMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *IndividualSportMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *IndividualSportMutation) ResetCountry() {
	m.country = nil
}

// SetSport sets the "sport" field.
func (m *IndividualSportMutation) SetSport(s string) {
	m.sport = &s
}

// Sport returns the value of the "sport" field in the mutation.
func (m *IndividualSportMutation) Sport() (r string, exists bool) {
	v := m.sport
	if v == nil {
		return
	}
	return *v, true
}

// OldSport returns the old "sport" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldSport(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSport: %w", err)
	}
	return oldValue.Sport, nil
}

// ResetSport resets all changes to the "sport" field.
func (m *IndividualSportMutation) ResetSport() {
	m.sport = nil
}

// SetGold sets the "gold" field.
func (m *IndividualSportMutation) SetGold(i int) {
	m.gold = &i
	m.addgold = nil
}

// Gold returns the value of the "gold" field in the mutation.
func (m *IndividualSportMutation) Gold() (r int, exists bool) {
	v := m.gold
	if v == nil {
		return
	}
	return *v, true
}

// OldGold returns the old "gold" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldGold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGold: %w", err)
	}
	return oldValue.Gold, nil
}

// AddGold adds i to the "gold" field.
func (m *IndividualSportMutation) AddGold(i int) {
	if m.addgold != nil {
		*m.addgold += i
	} else {
		m.addgold = &i
	}
}

// AddedGold returns the value that was added to the "gold" field in this mutation.
func (m *IndividualSportMutation) AddedGold() (r int, exists bool) {
	v := m.addgold
	if v == nil {
		return
	}
	return *v, true
}

// ResetGold resets all changes to the "gold" field.
func (m *IndividualSportMutation) ResetGold() {
	m.gold = nil
	m.addgold = nil
}

// SetSilver sets the "silver" field.
func (m *IndividualSportMutation) SetSilver(i int) {
	m.silver = &i
	m.addsilver = nil
}

// Silver returns the value of the "silver" field in the mutation.
func (m *IndividualSportMutation) Silver() (r int, exists bool) {
	v := m.silver
	if v == nil {
		return
	}
	return *v, true
}

// OldSilver returns the old "silver" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldSilver(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSilver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSilver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSilver: %w", err)
	}
	return oldValue.Silver, nil
}

// AddSilver adds i to the "silver" field.
func (m *IndividualSportMutation) AddSilver(i int) {
	if m.addsilver != nil {
		*m.addsilver += i
	} else {
		m.addsilver = &i
	}
}

// AddedSilver returns the value that was added to the "silver" field in this mutation.
func (m *IndividualSportMutation) AddedSilver() (r int, exists bool) {
	v := m.addsilver
	if v == nil {
		return
	}
	return *v, true
}

// ResetSilver resets all changes to the "silver" field.
func (m *IndividualSportMutation) ResetSilver() {
	m.silver = nil
	m.addsilver = nil
}

// SetBronze sets the "bronze" field.
func (m *IndividualSportMutation) SetBronze(i int) {
	m.bronze = &i
	m.addbronze = nil
}

// Bronze returns the value of the "bronze" field in the mutation.
func (m *IndividualSportMutation) Bronze() (r int, exists bool) {
	v := m.bronze
	if v == nil {
		return
	}
	return *v, true
}

// OldBronze returns the old "bronze" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldBronze(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBronze is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBronze requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBronze: %w", err)
	}
	return oldValue.Bronze, nil
}

// AddBronze adds i to the "bronze" field.
func (m *IndividualSportMutation) AddBronze(i int) {
	if m.addbronze != nil {
		*m.addbronze += i
	} else {
		m.addbronze = &i
	}
}

// AddedBronze returns the value that was added to the "bronze" field in this mutation.
func (m *IndividualSportMutation) AddedBronze() (r int, exists bool) {
	v := m.addbronze
	if v == nil {
		return
	}
	return *v, true
}

// ResetBronze resets all changes to the "bronze" field.
func (m *IndividualSportMutation) ResetBronze() {
	m.bronze = nil
	m.addbronze = nil
}

// SetPoints sets the "points" field.
func (m *IndividualSportMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *IndividualSportMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *IndividualSportMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *IndividualSportMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *IndividualSportMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetTotalScore sets the "total_score" field.
func (m *IndividualSportMutation) SetTotalScore(i int) {
	m.total_score = &i
	m.addtotal_score = nil
}

// TotalScore returns the value of the "total_score" field in the mutation.
func (m *IndividualSportMutation) TotalScore() (r int, exists bool) {
	v := m.total_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalScore returns the old "total_score" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldTotalScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalScore: %w", err)
	}
	return oldValue.TotalScore, nil
}

// AddTotalScore adds i to the "total_score" field.
func (m *IndividualSportMutation) AddTotalScore(i int) {
	if m.addtotal_score != nil {
		*m.addtotal_score += i
	} else {
		m.addtotal_score = &i
	}
}

// AddedTotalScore returns the value that was added to the "total_score" field in this mutation.
func (m *IndividualSportMutation) AddedTotalScore() (r int, exists bool) {
	v := m.addtotal_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalScore resets all changes to the "total_score" field.
func (m *IndividualSportMutation) ResetTotalScore() {
	m.total_score = nil
	m.addtotal_score = nil
}

// SetPopulation sets the "population" field.
func (m *IndividualSportMutation) SetPopulation(i int) {
	m.population = &i
	m.addpopulation = nil
}

// Population returns the value of the "population" field in the mutation.
func (m *IndividualSportMutation) Population() (r int, exists bool) {
	v := m.population
	if v == nil {
		return
	}
	return *v, true
}

// OldPopulation returns the old "population" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldPopulation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopulation: %w", err)
	}
	return oldValue.Population, nil
}

// AddPopulation adds i to the "population" field.
func (m *IndividualSportMutation) AddPopulation(i int) {
	if m.addpopulation != nil {
		*m.addpopulation += i
	} else {
		m.addpopulation = &i
	}
}

// AddedPopulation returns the value that was added to the "population" field in this mutation.
func (m *IndividualSportMutation) AddedPopulation() (r int, exists bool) {
	v := m.addpopulation
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulation resets all changes to the "population" field.
func (m *IndividualSportMutation) ResetPopulation() {
	m.population = nil
	m.addpopulation = nil
}

// SetPerCapita sets the "per_capita" field.
func (m *IndividualSportMutation) SetPerCapita(f float64) {
	m.per_capita = &f
	m.addper_capita = nil
}

// PerCapita returns the value of the "per_capita" field in the mutation.
func (m *IndividualSportMutation) PerCapita() (r float64, exists bool) {
	v := m.per_capita
	if v == nil {
		return
	}
	return *v, true
}

// OldPerCapita returns the old "per_capita" field's value of the IndividualSport entity.
// If the IndividualSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualSportMutation) OldPerCapita(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerCapita is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerCapita requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerCapita: %w", err)
	}
	return oldValue.PerCapita, nil
}

// AddPerCapita adds f to the "per_capita" field.
func (m *IndividualSportMutation) AddPerCapita(f float64) {
	if m.addper_capita != nil {
		*m.addper_capita += f
	} else {
		m.addper_capita = &f
	}
}

// AddedPerCapita returns the value that was added to the "per_capita" field in this mutation.
func (m *IndividualSportMutation) AddedPerCapita() (r float64, exists bool) {
	v := m.addper_capita
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerCapita resets all changes to the "per_capita" field.
func (m *IndividualSportMutation) ResetPerCapita() {
	m.per_capita = nil
	m.addper_capita = nil
}

// Where appends a list predicates to the IndividualSportMutation builder.
func (m *IndividualSportMutation) Where(ps ...predicate.IndividualSport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IndividualSportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IndividualSportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IndividualSport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IndividualSportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IndividualSportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IndividualSport).
func (m *IndividualSportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndividualSportMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.country != nil {
		fields = append(fields, individualsport.FieldCountry)
	}
	if m.sport != nil {
		fields = append(fields, individualsport.FieldSport)
	}
	if m.gold != nil {
		fields = append(fields, individualsport.FieldGold)
	}
	if m.silver != nil {
		fields = append(fields, individualsport.FieldSilver)
	}
	if m.bronze != nil {
		fields = append(fields, individualsport.FieldBronze)
	}
	if m.points != nil {
		fields = append(fields, individualsport.FieldPoints)
	}
	if m.total_score != nil {
		fields = append(fields, individualsport.FieldTotalScore)
	}
	if m.population != nil {
		fields = append(fields, individualsport.FieldPopulation)
	}
	if m.per_capita != nil {
		fields = append(fields, individualsport.FieldPerCapita)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndividualSportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case individualsport.FieldCountry:
		return m.Country()
	case individualsport.FieldSport:
		return m.Sport()
	case individualsport.FieldGold:
		return m.Gold()
	case individualsport.FieldSilver:
		return m.Silver()
	case individualsport.FieldBronze:
		return m.Bronze()
	case individualsport.FieldPoints:
		return m.Points()
	case individualsport.FieldTotalScore:
		return m.TotalScore()
	case individualsport.FieldPopulation:
		return m.Population()
	case individualsport.FieldPerCapita:
		return m.PerCapita()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndividualSportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case individualsport.FieldCountry:
		return m.OldCountry(ctx)
	case individualsport.FieldSport:
		return m.OldSport(ctx)
	case individualsport.FieldGold:
		return m.OldGold(ctx)
	case individualsport.FieldSilver:
		return m.OldSilver(ctx)
	case individualsport.FieldBronze:
		return m.OldBronze(ctx)
	case individualsport.FieldPoints:
		return m.OldPoints(ctx)
	case individualsport.FieldTotalScore:
		return m.OldTotalScore(ctx)
	case individualsport.FieldPopulation:
		return m.OldPopulation(ctx)
	case individualsport.FieldPerCapita:
		return m.OldPerCapita(ctx)
	}
	return nil, fmt.Errorf("unknown IndividualSport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndividualSportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case individualsport.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case individualsport.FieldSport:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSport(v)
		return nil
	case individualsport.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGold(v)
		return nil
	case individualsport.FieldSilver:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilver(v)
		return nil
	case individualsport.FieldBronze:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBronze(v)
		return nil
	case individualsport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case individualsport.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalScore(v)
		return nil
	case individualsport.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulation(v)
		return nil
	case individualsport.FieldPerCapita:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerCapita(v)
		return nil
	}
	return fmt.Errorf("unknown IndividualSport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndividualSportMutation) AddedFields() []string {
	var fields []string
	if m.addgold != nil {
		fields = append(fields, individualsport.FieldGold)
	}
	if m.addsilver != nil {
		fields = append(fields, individualsport.FieldSilver)
	}
	if m.addbronze != nil {
		fields = append(fields, individualsport.FieldBronze)
	}
	if m.addpoints != nil {
		fields = append(fields, individualsport.FieldPoints)
	}
	if m.addtotal_score != nil {
		fields = append(fields, individualsport.FieldTotalScore)
	}
	if m.addpopulation != nil {
		fields = append(fields, individualsport.FieldPopulation)
	}
	if m.addper_capita != nil {
		fields = append(fields, individualsport.FieldPerCapita)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndividualSportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case individualsport.FieldGold:
		return m.AddedGold()
	case individualsport.FieldSilver:
		return m.AddedSilver()
	case individualsport.FieldBronze:
		return m.AddedBronze()
	case individualsport.FieldPoints:
		return m.AddedPoints()
	case individualsport.FieldTotalScore:
		return m.AddedTotalScore()
	case individualsport.FieldPopulation:
		return m.AddedPopulation()
	case individualsport.FieldPerCapita:
		return m.AddedPerCapita()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndividualSportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case individualsport.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGold(v)
		return nil
	case individualsport.FieldSilver:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSilver(v)
		return nil
	case individualsport.FieldBronze:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBronze(v)
		return nil
	case individualsport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case individualsport.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalScore(v)
		return nil
	case individualsport.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulation(v)
		return nil
	case individualsport.FieldPerCapita:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerCapita(v)
		return nil
	}
	return fmt.Errorf("unknown IndividualSport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndividualSportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndividualSportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndividualSportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IndividualSport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndividualSportMutation) ResetField(name string) error {
	switch name {
	case individualsport.FieldCountry:
		m.ResetCountry()
		return nil
	case individualsport.FieldSport:
		m.ResetSport()
		return nil
	case individualsport.FieldGold:
		m.ResetGold()
		return nil
	case individualsport.FieldSilver:
		m.ResetSilver()
		return nil
	case individualsport.FieldBronze:
		m.ResetBronze()
		return nil
	case individualsport.FieldPoints:
		m.ResetPoints()
		return nil
	case individualsport.FieldTotalScore:
		m.ResetTotalScore()
		return nil
	case individualsport.FieldPopulation:
		m.ResetPopulation()
		return nil
	case individualsport.FieldPerCapita:
		m.ResetPerCapita()
		return nil
	}
	return fmt.Errorf("unknown IndividualSport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndividualSportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndividualSportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndividualSportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndividualSportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndividualSportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndividualSportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndividualSportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IndividualSport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndividualSportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IndividualSport edge %s", name)
}

// TeamSportMutation represents an operation that mutates the TeamSport nodes in the graph.
type TeamSportMutation struct {
	config
	op             Op
	typ            string
	id             *int
	country        *string
	sport          *string
	gold           *int
	addgold        *int
	silver         *int
	addsilver      *int
	bronze         *int
	addbronze      *int
	points         *int
	addpoints      *int
	total_score    *int
	addtotal_score *int
	population     *int
	addpopulation  *int
	per_capita     *float64
	addper_capita  *float64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*TeamSport, error)
	predicates     []predicate.TeamSport
}

var _ ent.Mutation = (*TeamSportMutation)(nil)

// teamsportOption allows management of the mutation configuration using functional options.
type teamsportOption func(*TeamSportMutation)

// newTeamSportMutation creates new mutation for the TeamSport entity.
func newTeamSportMutation(c config, op Op, opts ...teamsportOption) *TeamSportMutation {
	m := &TeamSportMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamSport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamSportID sets the ID field of the mutation.
func withTeamSportID(id int) teamsportOption {
	return func(m *TeamSportMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamSport
		)
		m.oldValue = func(ctx context.Context) (*TeamSport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamSport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamSport sets the old TeamSport of the mutation.
func withTeamSport(node *TeamSport) teamsportOption {
	return func(m *TeamSportMutation) {
		m.oldValue = func(context.Context) (*TeamSport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamSportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamSportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamSportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamSportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamSport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountry sets the "country" field.
func (m *TeamSportMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *TeamSportMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *TeamSportMutation) ResetCountry() {
	m.country = nil
}

// SetSport sets the "sport" field.
func (m *TeamSportMutation) SetSport(s string) {
	m.sport = &s
}

// Sport returns the value of the "sport" field in the mutation.
func (m *TeamSportMutation) Sport() (r string, exists bool) {
	v := m.sport
	if v == nil {
		return
	}
	return *v, true
}

// OldSport returns the old "sport" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldSport(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSport: %w", err)
	}
	return oldValue.Sport, nil
}

// ResetSport resets all changes to the "sport" field.
func (m *TeamSportMutation) ResetSport() {
	m.sport = nil
}

// SetGold sets the "gold" field.
func (m *TeamSportMutation) SetGold(i int) {
	m.gold = &i
	m.addgold = nil
}

// Gold returns the value of the "gold" field in the mutation.
func (m *TeamSportMutation) Gold() (r int, exists bool) {
	v := m.gold
	if v == nil {
		return
	}
	return *v, true
}

// OldGold returns the old "gold" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldGold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGold: %w", err)
	}
	return oldValue.Gold, nil
}

// AddGold adds i to the "gold" field.
func (m *TeamSportMutation) AddGold(i int) {
	if m.addgold != nil {
		*m.addgold += i
	} else {
		m.addgold = &i
	}
}

// AddedGold returns the value that was added to the "gold" field in this mutation.
func (m *TeamSportMutation) AddedGold() (r int, exists bool) {
	v := m.addgold
	if v == nil {
		return
	}
	return *v, true
}

// ResetGold resets all changes to the "gold" field.
func (m *TeamSportMutation) ResetGold() {
	m.gold = nil
	m.addgold = nil
}

// SetSilver sets the "silver" field.
func (m *TeamSportMutation) SetSilver(i int) {
	m.silver = &i
	m.addsilver = nil
}

// Silver returns the value of the "silver" field in the mutation.
func (m *TeamSportMutation) Silver() (r int, exists bool) {
	v := m.silver
	if v == nil {
		return
	}
	return *v, true
}

// OldSilver returns the old "silver" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldSilver(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSilver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSilver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSilver: %w", err)
	}
	return oldValue.Silver, nil
}

// AddSilver adds i to the "silver" field.
func (m *TeamSportMutation) AddSilver(i int) {
	if m.addsilver != nil {
		*m.addsilver += i
	} else {
		m.addsilver = &i
	}
}

// AddedSilver returns the value that was added to the "silver" field in this mutation.
func (m *TeamSportMutation) AddedSilver() (r int, exists bool) {
	v := m.addsilver
	if v == nil {
		return
	}
	return *v, true
}

// ResetSilver resets all changes to the "silver" field.
func (m *TeamSportMutation) ResetSilver() {
	m.silver = nil
	m.addsilver = nil
}

// SetBronze sets the "bronze" field.
func (m *TeamSportMutation) SetBronze(i int) {
	m.bronze = &i
	m.addbronze = nil
}

// Bronze returns the value of the "bronze" field in the mutation.
func (m *TeamSportMutation) Bronze() (r int, exists bool) {
	v := m.bronze
	if v == nil {
		return
	}
	return *v, true
}

// OldBronze returns the old "bronze" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldBronze(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBronze is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBronze requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBronze: %w", err)
	}
	return oldValue.Bronze, nil
}

// AddBronze adds i to the "bronze" field.
func (m *TeamSportMutation) AddBronze(i int) {
	if m.addbronze != nil {
		*m.addbronze += i
	} else {
		m.addbronze = &i
	}
}

// AddedBronze returns the value that was added to the "bronze" field in this mutation.
func (m *TeamSportMutation) AddedBronze() (r int, exists bool) {
	v := m.addbronze
	if v == nil {
		return
	}
	return *v, true
}

// ResetBronze resets all changes to the "bronze" field.
func (m *TeamSportMutation) ResetBronze() {
	m.bronze = nil
	m.addbronze = nil
}

// SetPoints sets the "points" field.
func (m *TeamSportMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *TeamSportMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *TeamSportMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *TeamSportMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *TeamSportMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetTotalScore sets the "total_score" field.
func (m *TeamSportMutation) SetTotalScore(i int) {
	m.total_score = &i
	m.addtotal_score = nil
}

// TotalScore returns the value of the "total_score" field in the mutation.
func (m *TeamSportMutation) TotalScore() (r int, exists bool) {
	v := m.total_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalScore returns the old "total_score" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldTotalScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalScore: %w", err)
	}
	return oldValue.TotalScore, nil
}

// AddTotalScore adds i to the "total_score" field.
func (m *TeamSportMutation) AddTotalScore(i int) {
	if m.addtotal_score != nil {
		*m.addtotal_score += i
	} else {
		m.addtotal_score = &i
	}
}

// AddedTotalScore returns the value that was added to the "total_score" field in this mutation.
func (m *TeamSportMutation) AddedTotalScore() (r int, exists bool) {
	v := m.addtotal_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalScore resets all changes to the "total_score" field.
func (m *TeamSportMutation) ResetTotalScore() {
	m.total_score = nil
	m.addtotal_score = nil
}

// SetPopulation sets the "population" field.
func (m *TeamSportMutation) SetPopulation(i int) {
	m.population = &i
	m.addpopulation = nil
}

// Population returns the value of the "population" field in the mutation.
func (m *TeamSportMutation) Population() (r int, exists bool) {
	v := m.population
	if v == nil {
		return
	}
	return *v, true
}

// OldPopulation returns the old "population" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldPopulation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopulation: %w", err)
	}
	return oldValue.Population, nil
}

// AddPopulation adds i to the "population" field.
func (m *TeamSportMutation) AddPopulation(i int) {
	if m.addpopulation != nil {
		*m.addpopulation += i
	} else {
		m.addpopulation = &i
	}
}

// AddedPopulation returns the value that was added to the "population" field in this mutation.
func (m *TeamSportMutation) AddedPopulation() (r int, exists bool) {
	v := m.addpopulation
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulation resets all changes to the "population" field.
func (m *TeamSportMutation) ResetPopulation() {
	m.population = nil
	m.addpopulation = nil
}

// SetPerCapita sets the "per_capita" field.
func (m *TeamSportMutation) SetPerCapita(f float64) {
	m.per_capita = &f
	m.addper_capita = nil
}

// PerCapita returns the value of the "per_capita" field in the mutation.
func (m *TeamSportMutation) PerCapita() (r float64, exists bool) {
	v := m.per_capita
	if v == nil {
		return
	}
	return *v, true
}

// OldPerCapita returns the old "per_capita" field's value of the TeamSport entity.
// If the TeamSport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSportMutation) OldPerCapita(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerCapita is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerCapita requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerCapita: %w", err)
	}
	return oldValue.PerCapita, nil
}

// AddPerCapita adds f to the "per_capita" field.
func (m *TeamSportMutation) AddPerCapita(f float64) {
	if m.addper_capita != nil {
		*m.addper_capita += f
	} else {
		m.addper_capita = &f
	}
}

// AddedPerCapita returns the value that was added to the "per_capita" field in this mutation.
func (m *TeamSportMutation) AddedPerCapita() (r float64, exists bool) {
	v := m.addper_capita
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerCapita resets all changes to the "per_capita" field.
func (m *TeamSportMutation) ResetPerCapita() {
	m.per_capita = nil
	m.addper_capita = nil
}

// Where appends a list predicates to the TeamSportMutation builder.
func (m *TeamSportMutation) Where(ps ...predicate.TeamSport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamSportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamSportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamSport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamSportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamSportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamSport).
func (m *TeamSportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamSportMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.country != nil {
		fields = append(fields, teamsport.FieldCountry)
	}
	if m.sport != nil {
		fields = append(fields, teamsport.FieldSport)
	}
	if m.gold != nil {
		fields = append(fields, teamsport.FieldGold)
	}
	if m.silver != nil {
		fields = append(fields, teamsport.FieldSilver)
	}
	if m.bronze != nil {
		fields = append(fields, teamsport.FieldBronze)
	}
	if m.points != nil {
		fields = append(fields, teamsport.FieldPoints)
	}
	if m.total_score != nil {
		fields = append(fields, teamsport.FieldTotalScore)
	}
	if m.population != nil {
		fields = append(fields, teamsport.FieldPopulation)
	}
	if m.per_capita != nil {
		fields = append(fields, teamsport.FieldPerCapita)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamSportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teamsport.FieldCountry:
		return m.Country()
	case teamsport.FieldSport:
		return m.Sport()
	case teamsport.FieldGold:
		return m.Gold()
	case teamsport.FieldSilver:
		return m.Silver()
	case teamsport.FieldBronze:
		return m.Bronze()
	case teamsport.FieldPoints:
		return m.Points()
	case teamsport.FieldTotalScore:
		return m.TotalScore()
	case teamsport.FieldPopulation:
		return m.Population()
	case teamsport.FieldPerCapita:
		return m.PerCapita()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamSportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teamsport.FieldCountry:
		return m.OldCountry(ctx)
	case teamsport.FieldSport:
		return m.OldSport(ctx)
	case teamsport.FieldGold:
		return m.OldGold(ctx)
	case teamsport.FieldSilver:
		return m.OldSilver(ctx)
	case teamsport.FieldBronze:
		return m.OldBronze(ctx)
	case teamsport.FieldPoints:
		return m.OldPoints(ctx)
	case teamsport.FieldTotalScore:
		return m.OldTotalScore(ctx)
	case teamsport.FieldPopulation:
		return m.OldPopulation(ctx)
	case teamsport.FieldPerCapita:
		return m.OldPerCapita(ctx)
	}
	return nil, fmt.Errorf("unknown TeamSport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamSportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teamsport.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case teamsport.FieldSport:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSport(v)
		return nil
	case teamsport.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGold(v)
		return nil
	case teamsport.FieldSilver:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilver(v)
		return nil
	case teamsport.FieldBronze:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBronze(v)
		return nil
	case teamsport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case teamsport.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalScore(v)
		return nil
	case teamsport.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulation(v)
		return nil
	case teamsport.FieldPerCapita:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerCapita(v)
		return nil
	}
	return fmt.Errorf("unknown TeamSport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamSportMutation) AddedFields() []string {
	var fields []string
	if m.addgold != nil {
		fields = append(fields, teamsport.FieldGold)
	}
	if m.addsilver != nil {
		fields = append(fields, teamsport.FieldSilver)
	}
	if m.addbronze != nil {
		fields = append(fields, teamsport.FieldBronze)
	}
	if m.addpoints != nil {
		fields = append(fields, teamsport.FieldPoints)
	}
	if m.addtotal_score != nil {
		fields = append(fields, teamsport.FieldTotalScore)
	}
	if m.addpopulation != nil {
		fields = append(fields, teamsport.FieldPopulation)
	}
	if m.addper_capita != nil {
		fields = append(fields, teamsport.FieldPerCapita)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamSportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teamsport.FieldGold:
		return m.AddedGold()
	case teamsport.FieldSilver:
		return m.AddedSilver()
	case teamsport.FieldBronze:
		return m.AddedBronze()
	case teamsport.FieldPoints:
		return m.AddedPoints()
	case teamsport.FieldTotalScore:
		return m.AddedTotalScore()
	case teamsport.FieldPopulation:
		return m.AddedPopulation()
	case teamsport.FieldPerCapita:
		return m.AddedPerCapita()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamSportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teamsport.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGold(v)
		return nil
	case teamsport.FieldSilver:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSilver(v)
		return nil
	case teamsport.FieldBronze:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBronze(v)
		return nil
	case teamsport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case teamsport.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalScore(v)
		return nil
	case teamsport.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulation(v)
		return nil
	case teamsport.FieldPerCapita:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerCapita(v)
		return nil
	}
	return fmt.Errorf("unknown TeamSport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamSportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamSportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamSportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeamSport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamSportMutation) ResetField(name string) error {
	switch name {
	case teamsport.FieldCountry:
		m.ResetCountry()
		return nil
	case teamsport.FieldSport:
		m.ResetSport()
		return nil
	case teamsport.FieldGold:
		m.ResetGold()
		return nil
	case teamsport.FieldSilver:
		m.ResetSilver()
		return nil
	case teamsport.FieldBronze:
		m.ResetBronze()
		return nil
	case teamsport.FieldPoints:
		m.ResetPoints()
		return nil
	case teamsport.FieldTotalScore:
		m.ResetTotalScore()
		return nil
	case teamsport.FieldPopulation:
		m.ResetPopulation()
		return nil
	case teamsport.FieldPerCapita:
		m.ResetPerCapita()
		return nil
	}
	return fmt.Errorf("unknown TeamSport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamSportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamSportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamSportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamSportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamSportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamSportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamSportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TeamSport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamSportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TeamSport edge %s", name)
}
